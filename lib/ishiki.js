var crypto = require('crypto'),
  nodev = require('./nodev');

module.exports = function(app, haibu, path, fs, drone) {
  app.router.path('/', function() {
    //list all drones
    this.get(function() {
      haibu.sendResponse(this.res, 200, {drones: drone.list()});
    });

    //list all drones for particular user
    this.get('/:userid', function(userid) {
      //var user_drones = drone.list().filter(function(d){ return d.user == userid; });

      haibu.sendResponse(this.res, 200, {drones: []});
    });

    //list all running drones
    this.get('/running', function() {
      haibu.sendResponse(this.res, 200, {drones: drone.running()});
    });

    //show status of particular app/drone for given user
    this.get('/:userid/:appid', function(userid, appid) {
      haibu.sendResponse(this.res, 200, {status: null});
    });

    //deploy app
    this.post('/:userid/:appid/deploy', {stream: true}, function(userid, appid) {
      var res = this.res,
        req = this.req,
        drone_app = null;

      //watching for new packages since deploy returns no info on package...
      var app_dir = null,
        watcher = fs.watch(app.config.get('haibu:directories:packages'), function(action, filename) {
          if (action == 'rename' && filename.indexOf(userid + '-' + appid + '-') === 0)
            app_dir = filename;
        });

      //check whether app is running before deployment
      if (drone.apps[appid] != undefined)
        drone_app = drone.apps[appid].app;

      function startDrone(pkg) {
        drone.start(pkg, function(err, result) {
          console.log(err, result);

          if (err)
            return haibu.sendResponse(res, 500, err);

          haibu.sendResponse(res, 200, { drone: result });
        });
      }

      function restartDrone(pkg, restart) {
        if (restart) {
          drone.stop(appid, function() {
            startDrone(pkg);
          });
        }else{
          startDrone(pkg)
        }
      }

      //clean up app
      drone.clean({user: userid, name: appid}, function() {
        //deploy
        drone.deploy(userid, appid, req, function(err, result) {
          watcher.close();

          //matching sha digest generated by haibu drone...
          var sha = crypto.createHash('sha1');

          function updateSha (chunk) {
            sha.update(chunk);
          }

          req.on('data', updateSha);
          if (req.chunks)
            req.chunks.forEach(updateSha);

          req.on('end', function() { req.removeListener('data', updateSha); });

          if (err) {
            console.log(err);

            if (app_dir) {
              //read package info
              var package_path = path.join(app.config.get('haibu:directories:packages'), app_dir, 'package.json');

              haibu.common.file.readJson(package_path, function (pkg_err, pkg) {
                if (pkg_err) {
                  haibu.emit(['error', 'service'], 'error', err);
                  return haibu.sendResponse(res, 500, { error: err });
                }

                //updating package info
                pkg.user = userid;
                pkg.name = appid;
                pkg.hash = sha.digest('hex');
                pkg.repository = {
                  type: 'local',
                  directory: app_dir
                };

                var node_version = new nodev.Nodev({
                  install_dir: app.config.get('haibu:directories:node-installs'),
                  tmp_dir: app.config.get('haibu:directories:tmp')
                });

                //check for node version
                if (pkg.engines && pkg.engines.node) {
                  node_version.checkInstall(pkg.engines.node, function(err, version_match) {
                    if (err)
                      return haibu.sendResponse(res, 500, {message: err.message});

                    restartDrone(pkg, drone_app);
                  });
                }
              });
            }
          }else{
            restartDrone(drone_app, drone_app);
          }
        });
      });
    });
  });
}